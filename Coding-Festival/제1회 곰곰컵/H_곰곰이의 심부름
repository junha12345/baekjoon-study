# s->c->h 오는 경로상 
# s->c 최단으로가는 경로 + c->h 최단으로 가는 경로 (순서중요)
import sys
input = sys.stdin.readline
sys.setrecursionlimit(10**6)
LOG = 21

n = int(input())
s, c, h = map(int, input().split()) # 현재도시, 심부름도시, 집위치
graph = [[] for _ in range(n+1)]
parent = [[0]*LOG for _ in range(n+1)]
dept = [0]*(n+1)
check = [0]*(n+1)
for _ in range(n-1) :
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)

def dfs(start, dp) :
    check[start] = 1
    dept[start] = dp
    for i in graph[start] :
        if check[i] : continue
        parent[i] = start
        road[i].extend(road[start])
        road[i].append(i)
        dfs(i, dp+1)

def find(x, y) :
    if dept[x]>dept[y] : x, y = y, x # dept[y]>dept[x]가 되도록
    for i in range(LOG-1, -1, -1) :
        if dept[y]-dept[x]>=(1<<i) :
            y = parent[y][i] # --> dept 통일
    if x==y : return x
    for i in range(LOG-1, -1, -1) :
        if parent[x][i] != parent[y][i] :
            x = parent[x][i]
            y = parent[y][i]
    return parent[x][0]

road = [[]for _ in range(n+1)] # 순서저장
dfs(s, 0)
for i in range(1,LOG) :
    for j in range(1, n+1) :
        parent[j][i] = parent[parent[j][i-1]][i-1]
pt = find(c, h)
# 공통조상=pt, 시작점=s ---> s->c->pt->h 경로
print(road)

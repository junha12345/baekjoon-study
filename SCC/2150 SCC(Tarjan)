# Tarjan 알고리즘
# 각 노드에 id, low 를 메겨서 부모의 low 를 따라감 --> 같은 low를 가진 노드끼리 SCC구성
import sys
input = sys.stdin.readline
sys.setrecursionlimit(10**6)

v, e = map(int, input().split())
graph = [[] for _ in range(v+1)]
for _ in range(e) :
    a, b = map(int, input().split())
    graph[a].append(b)

def dfs(node, low, ids, visited, stack) :
    global nid
    ids[node] = nid ; low[node] = nid
    nid += 1
    visited[node] = 1
    stack.append(node)
    for i in graph[node] :
        if visited[i] == 0 :
            dfs(i, low, ids, visited, stack)
            low[node] = min(low[node], low[i])
        elif visited[i] == 1:
            low[node] = min(low[node], low[i])
    w = -1
    scc = []
    if low[node] == ids[node] :
        while w != node :
            w = stack.pop()
            scc.append(w)
            visited[w] = -1
        ans.append(sorted(scc))

stack = []
ans = []
ids = [-1]*(v+1)
low = [-1]*(v+1)
visited = [0]*(v+1)
nid = 0
for i in range(1, v+1) :
    if ids[i] == - 1 :
        dfs(i, low, ids, visited, stack)
print(len(ans))
for i in sorted(ans) :
    print(*i, -1)
